# Macro System: R7RS Conformance Analysis

**Date:** October 29, 2025  
**Project:** rulesxp (samplescheme)  
**Files Analyzed:** `src/macro_compiler.rs`, `src/macro_matcher.rs`, `src/macro_expander.rs`, `src/macros.rs`, `prelude/macros.scm`

---

## Executive Summary

The macro system implements a **substantial subset of R7RS `syntax-rules`** with high-quality pattern matching, template expansion, and compile-time validation. The implementation has clear architectural boundaries (compiler ‚Üí matcher ‚Üí expander) and excellent error reporting.

**Overall Conformance:** ~80% of R7RS syntax-rules features implemented
- ‚úÖ Core pattern/template system working for single-level ellipsis.
- ‚úÖ Compile-time validation of pattern/template consistency.
- ‚ö†Ô∏è **CRITICAL GAP**: The system **does not support nested ellipsis repetition** (e.g., `... ...`), which is a significant deviation from R7RS and prevents common macro patterns.
- ‚ö†Ô∏è Missing: Hygiene, quasiquotation, some advanced features.
- üö´ Intentional restrictions due to project scope (no vectors, improper lists).

---

## 1. PARTIALLY IMPLEMENTED R7RS FEATURES ‚ö†Ô∏è

### 1.1 Pattern Matching (src/macro_matcher.rs)
- ‚úÖ **Pattern variables**: Any symbol not in literals binds to values.
- ‚úÖ **Literal matching**: Exact symbol/value matching for pattern literals.
- ‚úÖ **Wildcard `_`**: Matches anything without binding.
- ‚úÖ **List structure matching**: Recursive `(pattern ...)` matching.
- ‚úÖ **Ellipsis patterns**: `(pattern ...)` for zero-or-more repetition.
- ‚úÖ **Empty ellipsis**: Zero-length repetitions handled correctly.
- ‚úÖ **Multiple variables in ellipsis**: All variables in same ellipsis get same repetition count.
- ‚úÖ **Constant patterns**: Numbers, strings, booleans match exactly like literals.
- ‚ö†Ô∏è **Nested Ellipsis**: The matcher correctly *parses* nested patterns like `((x ...) ...)` into a hierarchical `Binding::Repeated` structure, but the expander cannot consume this structure, making the feature non-functional.

### 1.2 Template Expansion (src/macro_expander.rs)
- ‚úÖ **Variable substitution**: Replace pattern variables with bound values.
- ‚úÖ **Literal templates**: Constants pass through unchanged.
- ‚úÖ **List template construction**: Build list structures from templates.
- ‚úÖ **Ellipsis replication**: `(template ...)` replicates based on binding repetition count for a single level.
- ‚úÖ **Empty ellipsis**: Zero-length repetitions produce empty lists.
- ‚ö†Ô∏è **Nested Ellipsis**: The expander **cannot** handle nested ellipsis templates like `((template ...) ...)` or `(x ... ...)`. It lacks the logic to process the nested `Binding::Repeated` structures generated by the matcher. This is a critical failure.

### 1.3 Compile-Time Validation (src/macro_compiler.rs)
- ‚úÖ **Depth consistency**: Each pattern variable must appear at exactly one ellipsis depth.
- ‚úÖ **Template depth validation**: Template depth cannot exceed pattern depth.
- ‚úÖ **Ellipsis position enforcement**: `...` must be last element in pattern/template list.
- ‚úÖ **Ellipsis restrictions**: Cannot appear as standalone element.
- ‚úÖ **Literals validation**: `...` and `_` cannot appear in literals list.
- ‚úÖ **Pattern/template variable matching**: All template pattern vars must exist in pattern.
- ‚úÖ **Error messages**: Include macro name, rule number, and clear descriptions.

### 1.4 Macro Forms (src/macros.rs)
- ‚úÖ **`define-syntax`**: Basic macro definition form.
- ‚úÖ **`syntax-rules`**: `(syntax-rules (<literal> ...) <rule> ...)`
- ‚úÖ **Literal list**: Symbols in literals list treated as keywords.
- ‚úÖ **Multiple rules**: Macro can have multiple pattern/template rules.
- ‚úÖ **Rule ordering**: First matching rule wins (top-to-bottom).
- ‚úÖ **Expansion iteration**: Expands until no more macros found (with recursion limit).

### 1.5 Standard Derived Expressions (prelude/macros.scm)
All R7RS derived expressions implemented as macros:
- ‚úÖ `and`, `or` - logical operators (R7RS 4.2.1)
- ‚úÖ `when`, `unless` - simple conditionals (R7RS 4.2.6)
- ‚úÖ `cond` (with `else` and `=>`) - multi-way conditionals (R7RS 4.2.1)
- ‚úÖ `case` (with `else`) - multi-way conditionals (R7RS 4.2.5)
- ‚úÖ `let`, `let*` - local binding forms (R7RS 4.2.2)
- ‚úÖ Named `let` - recursive local binding
- ‚úÖ `do` - iteration form (R7RS 4.2.4)
- ‚úÖ `case-lambda` - multiple arity procedures

---

## 2. R7RS DEVIATIONS ‚ö†Ô∏è

### 2.1 **CRITICAL: No Support for Nested Ellipsis Repetition (`... ...`)**
**Location:** `src/macro_expander.rs`
**Status:** Not Implemented
**R7RS Requirement:** Section 4.3.2 implies that nested ellipsis patterns should be fully supported for matching and template expansion.

**Impact:**
Macros that require matching or expanding multiple levels of repetition fail. This is a significant limitation that prevents the implementation of common recursive patterns, such as flattening a list of lists.

**Example (Fails):**
```scheme
;; This is a standard R7RS macro that should work but fails in our implementation.
(define-syntax flatten
  (syntax-rules ()
    ((flatten ((x ...) ...))
     (list x ... ...))))

(flatten ((1 2) (3 4)))
;; Expected: (list 1 2 3 4)
;; Actual: Fails during expansion with a type error.
```

**Why Not Fixed:**
- The `macro_matcher.rs` correctly parses the pattern `((x ...) ...)` and creates a nested `Binding::Repeated` structure.
- However, the `macro_expander.rs` (`expand_ellipsis_template`) is not designed to handle this nested structure. It can only process a single level of repetition. When it encounters the template `(list x ... ...)`, it does not know how to "unzip" the two levels of `...` from the nested bindings of `x`.
- Fixing this requires a significant redesign of the template expansion logic to recursively handle nested repetition contexts.

**Enforcement:** ‚ùå The system fails at runtime during macro expansion, not at compile-time.

### 2.2 **CRITICAL: No Macro Hygiene**
**Location:** Entire macro system  
**Status:** Not implemented  
**R7RS Requirement:** Section 4.3.2 - Pattern Language

**Impact:**
```scheme
;; R7RS requires this to work hygienically:
(define-syntax my-let
  (syntax-rules ()
    ((_ ((var val)) body)
     ((lambda (var) body) val))))

(let ((lambda 5))  ; shadow 'lambda' in outer scope
  (my-let ((x 10)) x))  ; R7RS: should return 10
                         ; Our impl: 'lambda' captured, error!
```

**Why Not Fixed:**
- Requires alpha-renaming or identifier marks/colors.
- Needs gensym or unique identifier generation.
- Must track lexical scoping during expansion.
- Significant architectural change to macro system.

**Workaround:** Avoid shadowing special forms in macro-using code.

**Enforcement:** ‚ùå Cannot detect or prevent at compile-time without hygiene.

---

### 2.3 **Literal Identifier Shadowing**
**Location:** `prelude/macros.scm` (cond, case macros)  
**Status:** Structural matching instead of free-identifier=?

**R7RS Requirement:** Section 4.3.2 - Literals should use free-identifier=? comparison

**Impact:**
```scheme
;; R7RS: locally shadowed literals shouldn't match
(let ((else #f))
  (cond (#t else)))  ; R7RS: should NOT match else clause
                      ; Our impl: WILL match (structural)
```

**Why Not Fixed:**
- Requires identifier comparison with lexical scope tracking.
- Needs hygiene infrastructure (alpha-renaming).
- Current implementation does simple symbol string matching.

**Enforcement:** ‚ùå `NEEDS-ENFORCEMENT` comment in macros.scm line 58

**Workaround:** Don't shadow literal keywords (`else`, `=>`) in code using these macros.

---

### 2.4 **Quote Expansion Behavior**
**Location:** `src/macro_compiler.rs`, `src/macro_expander.rs`  
**Status:** Pattern variables inside quotes are expanded

**R7RS Ambiguity:** Section 4.3.2 doesn't clearly specify behavior

**Our Behavior:**
```scheme
(define-syntax test
  (syntax-rules ()
    ((_ x) 'x)))  ; Pattern variable 'x' in quoted context

(test 123)  ; Returns: (quote 123)  NOT: (quote x)
```

**Discussion:**
- Some Scheme implementations expand pattern variables in quotes.
- Others treat quoted identifiers as literals.
- R7RS spec is ambiguous on this edge case.
- Our implementation: consistent recursive expansion.

**Enforcement:** ‚úÖ Current behavior is consistent and documented.

---

### 2.5 **`define-syntax` Not Removed from AST**
**Location:** `src/macros.rs`  
**Status:** Macro definitions remain in expanded AST

**R7RS Requirement:** Macro definitions should not appear in compiled code

**Impact:**
The `define-syntax` form remains in the AST after expansion, which can cause errors in later processing stages if they don't expect it.

**Why Not Fixed:**
- Requires a filtering pass after macro expansion.
- Current AST walker doesn't remove definition forms.
- Low priority - macros work, just leaves definitions behind.

**Enforcement:** ‚ö†Ô∏è ProcessedAST compilation detects and errors.

**Workaround:** Prelude macros are loaded separately; user macros expand correctly but leave the definition artifact.

---

## 3. R7RS RESTRICTED (Intentional Limitations) üö´

### 3.1 **No Vector Patterns/Templates**
**Location:** All macro files  
**Status:** Project has no vector support

**R7RS Feature:** Section 4.3.2 - `#(pattern ...)` and `#(template ...)`

**Why Restricted:**
- Project scope: only proper lists supported.
- No `Value::Vector` type exists.
- Would require vector literal parsing and construction.

**Enforcement:** ‚úÖ Parser doesn't support vector literals.

---

### 3.2 **No Improper List Patterns/Templates**
**Location:** All macro files  
**Status:** Project only supports proper lists

**R7RS Feature:** Section 4.3.2 - `(a b . rest)` patterns/templates

**Why Restricted:**
- Project scope limitation.
- Dot notation parsing not implemented.
- `Value::Pair` structure not designed for improper lists.

**Enforcement:** ‚úÖ Parser doesn't support dot notation.

---

### 3.3 **Ellipsis Position in Lists**
**Location:** `src/macro_compiler.rs` lines 244-256  
**Status:** Enforced at compile-time (R7RS Compliant)

**R7RS Feature:** In `syntax-rules`, the ellipsis (`...`) must be the last element in a list pattern. The form `(a ... b)` is not part of the R7RS "small" language specification for `syntax-rules`. It is an extension found in other macro systems like `syntax-case`.

**Our Implementation (Compliant):**
- Our compiler correctly enforces that `...` must follow an element in a pattern list.
- This is compliant with the formal grammar in R7RS Section 7.1.6.

**Example (Correctly Rejected):**
```scheme
;; This is NOT valid R7RS syntax-rules and is correctly rejected
(define-syntax test
  (syntax-rules ()
    ((_ first ... rest)  ; Ellipsis not at end - ERROR
     (list first ... rest))))
```

**Enforcement:** ‚úÖ Compile-time error: "Ellipsis '...' must be the last element in a pattern list"

---

### 3.4 **Ellipsis Cannot Appear in Literals List**
**Location:** `src/macro_compiler.rs` lines 174-180  
**Status:** Enforced at compile-time

**R7RS Feature:** Section 4.3.2 - Can use `...` as literal by including in literals list

**Why Restricted:**
- Ellipsis is fundamental syntax in our parser.
- Making it a literal would require separate "ellipsis identifier" vs "ellipsis syntax".
- Would complicate all pattern/template parsing.

**Enforcement:** ‚úÖ Compile-time error: "Ellipsis '...' cannot appear in literals list"

---

### 3.5 **Underscore `_` Reserved as Wildcard**
**Location:** `src/macro_compiler.rs` line 177  
**Status:** Cannot appear in literals list

**R7RS Feature:** `_` can be used as regular identifier

**Why Restricted:**
- Consistent wildcard syntax (like Rust, Haskell).
- Simplifies pattern matching logic.
- Common convention in modern Schemes.

**Enforcement:** ‚úÖ Compile-time error: "Underscore '_' cannot appear in literals list"

---

### 3.6 **No Quasiquotation in Macros**
**Location:** Parser doesn't support backquote  
**Status:** `` `x ``, `,x`, `,@x` not implemented

**R7RS Feature:** Quasiquotation (Section 4.2.8) - convenient for macro templates

**Why Restricted:**
- Parser doesn't recognize backquote/comma syntax.
- `syntax-rules` templates work without it.

**Enforcement:** ‚úÖ Parser errors on backquote.

---

### 3.7 **No `syntax-case` or `syntax`**
**Location:** Not implemented  
**Status:** Only `syntax-rules` supported

**R7RS Feature:** Advanced macro systems (not in R7RS-small, but common)

**Why Restricted:**
- Project scope: `syntax-rules` sufficient for derived expressions.
- R7RS-small only requires `syntax-rules`.

**Enforcement:** ‚úÖ Not provided.

---

## 4. MISSING R7RS FEATURES (Not Yet Implemented) ‚ùå

### 4.1 **`let-syntax` and `letrec-syntax`**
**Location:** Not implemented  
**Status:** No local macro definitions

**R7RS Feature:** Section 4.3.1 - Local macro bindings

**Impact:**
```scheme
;; NOT SUPPORTED:
(let-syntax ((id (syntax-rules () ((_ x) x))))
  (id 42))  ; Local macro - ERROR
```

**Why Not Implemented:**
- Requires macro environment stacking.
- Need scope tracking for local definitions.
- Low priority - top-level macros sufficient for most uses.

**Enforcement:** ‚ö†Ô∏è ProcessedAST errors: "Local macro definitions not supported"

---

## 5. CONCLUSION

This is a partial implementation of R7RS `syntax-rules` with a solid foundation. However, it has **critical gaps** that limit its utility and conformance:

1.  **Nested Ellipsis (`... ...`)**: The inability to expand nested repetitions is the most severe functional limitation.
2.  **Hygiene**: The lack of hygiene makes macro composition unsafe and deviates significantly from R7RS principles.
3.  **Local Macros (`let-syntax`)**: A missing feature required by the standard.

The intentional restrictions are reasonable, but the core functional gaps make this a non-compliant subset of R7RS.

**Recommendation:** The highest priority for this system is to fix the **nested ellipsis expansion**. Without it, many standard and useful macros cannot be written. After that, implementing hygiene would be the next step toward true R7RS conformance.

