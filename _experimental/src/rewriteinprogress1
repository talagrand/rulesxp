// Macro expansion system - implements R7RS syntax-rules macros
use crate::value::{Environment, Value};
use std::collections::{HashMap, HashSet};
use std::rc::Rc;

pub const STANDARD_DERIVED_EXPRESSIONS: &[&str] = &[
    "and", "or", "when", "unless", "cond", "case", "let", "let*", "do",
];

// Global debug flag - set via environment variable MACRO_DEBUG=1
static DEBUG: std::sync::LazyLock<bool> = std::sync::LazyLock::new(|| {
    std::env::var("MACRO_DEBUG").is_ok()
});

macro_rules! debug_trace {
    ($($arg:tt)*) => {
        if *DEBUG {
            eprintln!("[MACRO DEBUG] {}", format!($($arg)*));
        }
    };
}

#[derive(Debug, Clone)]
pub struct MacroError(pub String);

impl std::fmt::Display for MacroError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Macro error: {}", self.0)
    }
}

impl std::error::Error for MacroError {}

#[derive(Debug, Clone, PartialEq)]
pub enum MacroPattern {
    Literal(String),
    Variable(String),
    Wildcard,
    List(Vec<MacroPattern>),
    Ellipsis(Box<MacroPattern>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum MacroTemplate {
    Literal(Value),
    Variable(String),
    List(Vec<MacroTemplate>),
    Ellipsis(Box<MacroTemplate>),
}

#[derive(Debug, Clone)]
pub struct SyntaxRule {
    pub pattern: MacroPattern,
    pub template: MacroTemplate,
}

#[derive(Debug, Clone)]
pub struct MacroDefinition {
    pub name: String,
    pub literals: Vec<String>,
    pub rules: Vec<SyntaxRule>,
}

// Hierarchical binding system for proper R7RS nested ellipsis semantics
// This represents the full complexity of pattern variable bindings across
// multiple levels of ellipsis nesting.
#[derive(Debug, Clone, PartialEq)]
pub enum Binding {
    /// Direct value binding - variable matched a single value (no ellipsis involved)
    Direct(Value),
    
    /// Repeated binding - variable appeared in ellipsis pattern, matched multiple times
    /// Each element can itself be Direct or Repeated (for nested ellipsis)
    Repeated {
        count: usize,
        elements: Vec<Binding>,
    },
}

impl Binding {
    /// Helper to get repetition count (0 for Direct, count for Repeated)
    fn repetition_count(&self) -> usize {
        match self {
            Binding::Direct(_) => 0,
            Binding::Repeated { count, .. } => *count,
        }
    }
    
    /// Helper to get the i-th element for template expansion
    fn get_element(&self, index: usize) -> Option<&Binding> {
        match self {
            Binding::Direct(_) => None,
            Binding::Repeated { elements, .. } => elements.get(index),
        }
    }
    
    /// Convert to direct Value (for non-ellipsis context)
    fn to_value(&self) -> Option<&Value> {
        match self {
            Binding::Direct(v) => Some(v),
            Binding::Repeated { .. } => None,
        }
    }
    
    /// Format for debug output - compact representation
    fn debug_format(&self) -> String {
        match self {
            Binding::Direct(v) => format!("Direct({})", value_compact(v)),
            Binding::Repeated { count, elements } => {
                let elem_strs: Vec<_> = elements.iter().map(|e| e.debug_format()).collect();
                format!("Repeated[{}]({})", count, elem_strs.join(", "))
            }
        }
    }
}

// Helper for compact value display in debug output
fn value_compact(v: &Value) -> String {
    match v {
        Value::Symbol(s) => s.clone(),
        Value::Integer(n) => n.to_string(),
        Value::Boolean(b) => if *b { "#t" } else { "#f" },
        Value::String(s) => format!("\"{}\"", s),
        Value::List(items) => {
            let item_strs: Vec<_> = items.iter().map(value_compact).collect();
            format!("({})", item_strs.join(" "))
        }
        _ => format!("{:?}", v),
    }
}

// Pattern matching context with hierarchical bindings
#[derive(Debug, Clone)]
struct MatchContext {
    bindings: HashMap<String, Binding>,
}

pub struct MacroExpander {
    macros: HashMap<String, MacroDefinition>,
    known_macro_symbols: HashSet<String>,
    expansion_dirty: bool,
}

impl MacroExpander {
    pub fn new(_environment: Rc<Environment>) -> Self {
        MacroExpander {
            macros: HashMap::new(),
            known_macro_symbols: HashSet::new(),
            expansion_dirty: false,
        }
    }

    pub fn expand(&mut self, ast: &Value) -> Result<Value, MacroError> {
        self.expand_until_stable(ast)
    }

    fn expand_until_stable(&mut self, ast: &Value) -> Result<Value, MacroError> {
        use std::borrow::Cow;
        const MAX_EXPANSIONS: usize = 100;
        let mut current = Cow::Borrowed(ast);
        let mut expansion_count = 0;

        loop {
            self.expansion_dirty = false;
            let expanded = self.expand_once(&current)?;

            if !self.expansion_dirty {
                return Ok(current.into_owned());
            }

            current = Cow::Owned(expanded);
            expansion_count += 1;

            if expansion_count > MAX_EXPANSIONS {
                return Err(MacroError(format!(
                    "Expression expansion exceeded {} iterations. This suggests infinite macro expansion.",
                    MAX_EXPANSIONS
                )));
            }
        }
    }

    fn expand_once(&mut self, ast: &Value) -> Result<Value, MacroError> {
        match ast {
            Value::List(items) if !items.is_empty() => {
                if let Value::Symbol(name) = &items[0] {
                    if name == "define-syntax" {
                        return self.handle_define_syntax(items);
                    }
                    if let Some(macro_def) = self.get_macro(name) {
                        self.expansion_dirty = true;
                        return self.expand_macro_rule(&macro_def, items);
                    }
                }

                let expanded_items: Result<Vec<_>, _> =
                    items.iter().map(|item| self.expand_once(item)).collect();

                let final_items: Vec<_> = expanded_items?
                    .into_iter()
                    .filter(|v| !matches!(v, Value::Unspecified))
                    .collect();

                if final_items != *items {
                    self.expansion_dirty = true;
                }
                Ok(Value::List(final_items))
            }
            _ => Ok(ast.clone()),
        }
    }

    fn handle_define_syntax(&mut self, items: &[Value]) -> Result<Value, MacroError> {
        if items.len() != 3 {
            return Err(MacroError(
                "define-syntax requires exactly 2 arguments".to_string(),
            ));
        }
        let name = match &items[1] {
            Value::Symbol(s) => s.clone(),
            _ => {
                return Err(MacroError(
                    "define-syntax name must be a symbol".to_string(),
                ))
            }
        };
        let macro_def = self.parse_syntax_rules(&name, &items[2])?;
        self.store_macro(macro_def)?;
        Ok(Value::Unspecified)
    }

    fn parse_syntax_rules(
        &self,
        name: &str,
        syntax_rules: &Value,
    ) -> Result<MacroDefinition, MacroError> {
        match syntax_rules {
            Value::List(items)
                if items.len() >= 2
                    && matches!(&items[0], Value::Symbol(s) if s == "syntax-rules") =>
            {
                let literals = self.parse_literals(&items[1])?;
                let rules_values = &items[2..];

                let rules = rules_values
                    .iter()
                    .map(|rule_item| self.parse_rule(rule_item, &literals))
                    .collect::<Result<Vec<_>, _>>()?;

                if rules.is_empty() {
                    return Err(MacroError(format!(
                        "syntax-rules for '{}' must have at least one rule.",
                        name
                    )));
                }

                Ok(MacroDefinition {
                    name: name.to_string(),
                    literals,
                    rules,
                })
            }
            _ => Err(MacroError("Invalid syntax-rules form".to_string())),
        }
    }

    fn parse_literals(&self, literals_val: &Value) -> Result<Vec<String>, MacroError> {
        match literals_val {
            Value::List(items) => items
                .iter()
                .map(|item| match item {
                    Value::Symbol(s) => Ok(s.clone()),
                    _ => Err(MacroError(format!(
                        "Invalid literal in syntax-rules literals list: expected symbol, found {}",
                        item
                    ))),
                })
                .collect(),
            _ => Err(MacroError(
                "Invalid literals list in syntax-rules: expected a list".to_string(),
            )),
        }
    }

    fn parse_rule(&self, rule: &Value, literals: &[String]) -> Result<SyntaxRule, MacroError> {
        match rule {
            Value::List(items) if items.len() == 2 => {
                let pattern = self.parse_pattern(&items[0], literals)?;
                let template = self.parse_template(&items[1])?;
                Ok(SyntaxRule { pattern, template })
            }
            _ => Err(MacroError(
                "Rule must be a list of pattern and template".to_string(),
            )),
        }
    }

    fn parse_pattern(
        &self,
        pattern: &Value,
        literals: &[String],
    ) -> Result<MacroPattern, MacroError> {
        match pattern {
            Value::Symbol(s) => {
                if literals.contains(s) {
                    Ok(MacroPattern::Literal(s.clone()))
                } else if s == "_" {
                    Ok(MacroPattern::Wildcard)
                } else {
                    Ok(MacroPattern::Variable(s.clone()))
                }
            }
            Value::List(items) => {
                let mut patterns = Vec::new();
                let mut it = items.iter().peekable();
                while let Some(item) = it.next() {
                    let sub_pattern = self.parse_pattern(item, literals)?;
                    if let Some(&Value::Symbol(s)) = it.peek() {
                        if s == "..." {
                            it.next(); // consume ellipsis
                            patterns.push(MacroPattern::Ellipsis(Box::new(sub_pattern)));
                            continue;
                        }
                    }
                    patterns.push(sub_pattern);
                }
                Ok(MacroPattern::List(patterns))
            }
            _ => Ok(MacroPattern::Literal(pattern.to_string())),
        }
    }

    fn parse_template(&self, template: &Value) -> Result<MacroTemplate, MacroError> {
        match template {
            Value::Symbol(s) => Ok(MacroTemplate::Variable(s.clone())),
            Value::List(items) => {
                let mut templates = Vec::new();
                let mut it = items.iter().peekable();
                while let Some(item) = it.next() {
                    let sub_template = self.parse_template(item)?;
                    if let Some(&Value::Symbol(s)) = it.peek() {
                        if s == "..." {
                            it.next(); // consume ellipsis
                            templates.push(MacroTemplate::Ellipsis(Box::new(sub_template)));
                            continue;
                        }
                    }
                    templates.push(sub_template);
                }
                Ok(MacroTemplate::List(templates))
            }
            _ => Ok(MacroTemplate::Literal(template.clone())),
        }
    }

    fn expand_macro_rule(
        &mut self,
        macro_def: &MacroDefinition,
        full_form: &[Value],
    ) -> Result<Value, MacroError> {
        for rule in &macro_def.rules {
            let mut context = MatchContext {
                bindings: HashMap::new(),
            };

            if self.match_pattern_new(
                &rule.pattern,
                &Value::List(full_form.to_vec()),
                &mut context,
                &macro_def.literals,
            ) {
                return self.expand_template_new(&rule.template, &context);
            }
        }
        Err(MacroError(format!(
            "No matching rule for macro {}",
            macro_def.name
        )))
    }

    // Pattern matching with hierarchical binding system
    // This creates proper nested Binding structures for ellipsis patterns
    fn match_pattern_new(
        &self,
        pattern: &MacroPattern,
        value: &Value,
        context: &mut MatchContext,
        literals: &[String],
    ) -> bool {
        match (pattern, value) {
            (MacroPattern::Literal(lit), Value::Symbol(s)) if lit == s => true,
            (MacroPattern::Literal(lit), other) if lit == &other.to_string() => true,
            (MacroPattern::Variable(name), _) => {
                // Variable matches any value - bind it directly
                context.bindings.insert(name.clone(), Binding::Direct(value.clone()));
                true
            }
            (MacroPattern::Wildcard, _) => true, // Wildcard matches anything without binding
            (MacroPattern::List(sub_patterns), Value::List(sub_values)) => {
                self.match_list_pattern_new(sub_patterns, sub_values, context, literals)
            }
            _ => false,
        }
    }

    // List pattern matching with hierarchical binding construction
    // Creates proper nested Repeated bindings for each ellipsis level
    fn match_list_pattern_new(
        &self,
        patterns: &[MacroPattern],
        values: &[Value],
        context: &mut MatchContext,
        literals: &[String],
    ) -> bool {
        let mut pattern_idx = 0;
        let mut value_idx = 0;

        while pattern_idx < patterns.len() {
            if let MacroPattern::Ellipsis(sub_pattern) = &patterns[pattern_idx] {
                // Handle ellipsis pattern - this is where hierarchical binding happens
                let remaining_patterns = &patterns[pattern_idx + 1..];

                // Find where ellipsis ends by looking ahead
                let mut ellipsis_end = values.len();
                if !remaining_patterns.is_empty() {
                    // Try to match remaining patterns from each possible position
                    for end_pos in value_idx..=values.len() {
                        let mut temp_context = context.clone();
                        if self.match_patterns_sequence(
                            remaining_patterns,
                            &values[end_pos..],
                            &mut temp_context,
                            literals,
                        ) {
                            ellipsis_end = end_pos;
                            break;
                        }
                    }
                }

                // Collect all variables in the ellipsis sub-pattern
                let ellipsis_vars = self.collect_pattern_vars(sub_pattern);

                // For each variable, we'll build a Repeated binding with proper structure
                let mut var_bindings: HashMap<String, Vec<Binding>> = HashMap::new();
                for var in &ellipsis_vars {
                    var_bindings.insert(var.clone(), Vec::new());
                }

                // Match each value in the ellipsis range
                let match_count = ellipsis_end - value_idx;
                for val_idx in value_idx..ellipsis_end {
                    // Create fresh context for this iteration
                    let mut temp_context = MatchContext {
                        bindings: HashMap::new(),
                    };

                    if !self.match_pattern_new(
                        sub_pattern,
                        &values[val_idx],
                        &mut temp_context,
                        literals,
                    ) {
                        return false; // Ellipsis match failed
                    }

                    // Collect the bindings from this iteration
                    // Each variable gets one Binding (which might itself be Repeated for nested ellipsis)
                    for var in &ellipsis_vars {
                        if let Some(binding) = temp_context.bindings.get(var) {
                            var_bindings.get_mut(var).unwrap().push(binding.clone());
                        } else {
                            // Variable didn't match in this iteration (zero-match case)
                            // This is OK for optional patterns, but all iterations must behave consistently
                        }
                    }
                }

                // Now store each variable's collected bindings as a Repeated binding
                for (var, bindings) in var_bindings {
                    if !bindings.is_empty() {
                        context.bindings.insert(
                            var,
                            Binding::Repeated {
                                count: match_count,
                                elements: bindings,
                            },
                        );
                    }
                }

                value_idx = ellipsis_end;
                pattern_idx += 1;
            } else {
                // Handle regular (non-ellipsis) pattern
                if value_idx >= values.len() {
                    return false;
                }

                if !self.match_pattern_new(
                    &patterns[pattern_idx],
                    &values[value_idx],
                    context,
                    literals,
                ) {
                    return false;
                }

                value_idx += 1;
                pattern_idx += 1;
            }
        }

        value_idx == values.len() // All values must be consumed
    }

    // Helper to match a sequence of patterns against values
    fn match_patterns_sequence(
        &self,
        patterns: &[MacroPattern],
        values: &[Value],
        context: &mut MatchContext,
        literals: &[String],
    ) -> bool {
        if patterns.is_empty() {
            return values.is_empty();
        }
        self.match_list_pattern_new(patterns, values, context, literals)
    }

    // Collect all variable names in a pattern
    fn collect_pattern_vars(&self, pattern: &MacroPattern) -> HashSet<String> {
        let mut vars = HashSet::new();
        match pattern {
            MacroPattern::Variable(name) => {
                vars.insert(name.clone());
            }
            MacroPattern::List(patterns) => {
                for p in patterns {
                    vars.extend(self.collect_pattern_vars(p));
                }
            }
            MacroPattern::Ellipsis(sub_pattern) => {
                vars.extend(self.collect_pattern_vars(sub_pattern));
            }
            _ => {}
        }
        vars
    }

    // Completely rewritten template expansion with proper R7RS semantics
    fn expand_template_new(
        &self,
        template: &MacroTemplate,
        context: &MatchContext,
    ) -> Result<Value, MacroError> {
        self.expand_template_with_quote(template, context, false)
    }

    fn expand_template_with_quote(
        &self,
        template: &MacroTemplate,
        context: &MatchContext,
        in_quote: bool,
    ) -> Result<Value, MacroError> {
        match template {
            MacroTemplate::Literal(val) => Ok(val.clone()),
            MacroTemplate::Variable(name) => {
                // Always substitute variables, regardless of quote context
                match context.bindings.get(name) {
                    Some(Binding::Direct(val)) => Ok(val.clone()),
                    Some(Binding::Repeated { .. }) => Err(MacroError(format!(
                        "Variable '{}' is bound to a repeated pattern but used in non-ellipsis context",
                        name
                    ))),
                    None => Ok(Value::Symbol(name.clone())), // Unbound variable becomes literal
                }
            }
            MacroTemplate::List(templates) => {
                // Check if this is a quote form
                if let Some(MacroTemplate::Variable(first)) = templates.get(0) {
                    if first == "quote" && templates.len() == 2 {
                        // This is (quote <something>), expand the quoted part with in_quote=true
                        let quoted_part =
                            self.expand_template_with_quote(&templates[1], context, true)?;
                        return Ok(Value::List(vec![
                            Value::Symbol("quote".to_string()),
                            quoted_part,
                        ]));
                    }
                }
                if let Some(MacroTemplate::Literal(Value::Symbol(first))) = templates.get(0) {
                    if first == "quote" && templates.len() == 2 {
                        // This is (quote <something>), expand the quoted part with in_quote=true
                        let quoted_part =
                            self.expand_template_with_quote(&templates[1], context, true)?;
                        return Ok(Value::List(vec![
                            Value::Symbol("quote".to_string()),
                            quoted_part,
                        ]));
                    }
                }

                // Regular list expansion
                let mut result = Vec::new();
                for tmpl in templates {
                    match tmpl {
                        MacroTemplate::Ellipsis(sub_template) => {
                            // Expand ellipsis considering quote context
                            if in_quote {
                                // Inside quote, expand but preserve quote semantics
                                let expanded_items =
                                    self.expand_ellipsis_with_quote(sub_template, context, true)?;
                                result.extend(expanded_items);
                            } else {
                                // Outside quote, normal expansion
                                let expanded_items =
                                    self.expand_ellipsis_new(sub_template, context)?;
                                result.extend(expanded_items);
                            }
                        }
                        _ => {
                            result.push(self.expand_template_with_quote(tmpl, context, in_quote)?);
                        }
                    }
                }
                Ok(Value::List(result))
            }
            MacroTemplate::Ellipsis(_) => Err(MacroError(
                "Ellipsis cannot appear at top level of template".to_string(),
            )),
        }
    }

    // Expand ellipsis template correctly with quote context awareness
    fn expand_ellipsis_with_quote(
        &self,
        sub_template: &MacroTemplate,
        context: &MatchContext,
        in_quote: bool,
    ) -> Result<Vec<Value>, MacroError> {
        // Find all variables in the sub-template
        let vars = self.collect_template_vars(sub_template);

        // Determine repetition count from ellipsis-bound variables
        let mut rep_count = None;
        let mut ellipsis_vars = HashSet::new();

        for var in &vars {
            if let Some(Binding::Repeated { count, .. }) = context.bindings.get(var) {
                ellipsis_vars.insert(var.clone());
                if let Some(existing_count) = rep_count {
                    if existing_count != *count {
                        return Err(MacroError(format!(
                            "Inconsistent ellipsis repetition counts: {} vs {} for variable '{}'",
                            existing_count, count, var
                        )));
                    }
                } else {
                    rep_count = Some(*count);
                }
            }
        }

        let rep_count = rep_count.unwrap_or(0);
        let mut results = Vec::new();

        // Expand once for each repetition
        for i in 0..rep_count {
            // Create local context for this iteration
            let mut local_context = MatchContext {
                bindings: context.bindings.clone(),
            };

            // Replace ellipsis-bound variables with their i-th element
            for var in &ellipsis_vars {
                if let Some(Binding::Repeated { elements, .. }) = context.bindings.get(var) {
                    if let Some(element) = elements.get(i) {
                        local_context.bindings.insert(var.clone(), element.clone());
                    }
                }
            }

            // Expand the sub-template with the local context and quote awareness
            let expanded =
                self.expand_template_with_quote(sub_template, &local_context, in_quote)?;
            results.push(expanded);
        }

        Ok(results)
    }

    // Expand ellipsis template correctly
    fn expand_ellipsis_new(
        &self,
        sub_template: &MacroTemplate,
        context: &MatchContext,
    ) -> Result<Vec<Value>, MacroError> {
        // Find all variables in the sub-template
        let vars = self.collect_template_vars(sub_template);

        // Determine repetition count from ellipsis-bound variables
        let mut rep_count = None;
        let mut ellipsis_vars = HashSet::new();

        for var in &vars {
            if let Some(Binding::Repeated { count, .. }) = context.bindings.get(var) {
                ellipsis_vars.insert(var.clone());
                if let Some(existing_count) = rep_count {
                    if existing_count != *count {
                        return Err(MacroError(format!(
                            "Inconsistent ellipsis repetition counts: {} vs {} for variable '{}'",
                            existing_count, count, var
                        )));
                    }
                } else {
                    rep_count = Some(*count);
                }
            }
        }

        let rep_count = rep_count.unwrap_or(0);
        let mut results = Vec::new();

        // Expand once for each repetition
        for i in 0..rep_count {
            // Create local context for this iteration
            let mut local_context = MatchContext {
                bindings: context.bindings.clone(),
            };

            // Replace ellipsis-bound variables with their i-th element
            for var in &ellipsis_vars {
                if let Some(Binding::Repeated { elements, .. }) = context.bindings.get(var) {
                    if let Some(element) = elements.get(i) {
                        local_context.bindings.insert(var.clone(), element.clone());
                    }
                }
            }

            // Expand the sub-template with the local context
            let expanded = self.expand_template_new(sub_template, &local_context)?;
            results.push(expanded);
        }

        Ok(results)
    }

    // Collect all variable names in a template
    fn collect_template_vars(&self, template: &MacroTemplate) -> HashSet<String> {
        let mut vars = HashSet::new();
        match template {
            MacroTemplate::Variable(name) => {
                vars.insert(name.clone());
            }
            MacroTemplate::List(templates) => {
                for t in templates {
                    vars.extend(self.collect_template_vars(t));
                }
            }
            MacroTemplate::Ellipsis(sub_template) => {
                vars.extend(self.collect_template_vars(sub_template));
            }
            _ => {}
        }
        vars
    }

    fn store_macro(&mut self, macro_def: MacroDefinition) -> Result<(), MacroError> {
        let name = macro_def.name.clone();
        self.macros.insert(name.clone(), macro_def);
        self.known_macro_symbols.insert(name);
        Ok(())
    }

    fn get_macro(&self, name: &str) -> Option<MacroDefinition> {
        self.macros.get(name).cloned()
    }

    pub fn load_prelude(&mut self) -> Result<(), MacroError> {
        let prelude_path = "prelude/macros.scm";
        let prelude_content = std::fs::read_to_string(prelude_path)
            .map_err(|e| MacroError(format!("Failed to read prelude file: {}", e)))?;

        let expressions = crate::parser::parse_multiple(&prelude_content)
            .map_err(|e| MacroError(format!("Failed to parse prelude file: {}", e)))?;

        for expr in expressions {
            self.expand_once(&expr)?;
        }

        Ok(())
    }
}

// Removed obsolete binding_value_to_value function - use Binding::to_value() method instead
